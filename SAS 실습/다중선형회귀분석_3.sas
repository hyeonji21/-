/* (조별 과제 : 데이터를 보고 순차적으로 진행을 했는지가 중요) */

/* 고전적 회귀 모형 -> advanced -> 이분산(시점에 따라 분산이 다를 때), 오차항(correlation있는지) 자기회귀모형 */


/* 1. 데이터 탐색
  그래프를 가지고 탐색을 해본다. (추세 -> 평균의 변동성, 변동성 -> (분산) 편차 : lag함수 사용하여 분산이 일정한지 아닌지 확인, 
                                   특이점 or 이상치 확인 -> 평균에 영향을 미친다. / 계수에 영향을 미친다.) 
  -> 우리가 쓰려고 하는 모형에 영향을 미친다.
*/

/* -> 모형 설정
/* 2. 진단
(1)[모수 or 계수 추정] b0, b1을 계산하여 [y=b0+b1x+오차]추정한다. 
(2) y - y^ : 잔차 / fitting한 후에 잔차가 작을수록 좋을 것이다.
(3)[잔차 진단] 잔차는 오차를 추정하는 것이기 때문에 information이 없어야한다. 
    이때, information : 추세, 변동성, 이상치 등이 없어야 한다. 
(4) classic 모형으로 진행이 불가하다고 할 경우 advanced 모형으로 진행 (모형이 유용한지)
*/


/* 단위 중요 */
/* MAF : 제조업 취업자수(명)
   SOC : 사회간접자본 및 기타서비스업 취업자수(명)
   WAGE : 제조업 월급여(정액급여+초과급여) (만원..?)
   time : 1년 단위
*/

data ex2_1;
 input MAF SOC WAGE;
 
 /* 차분된 값을 보기 위해 확인한다 */
 MAF_D = DIF(MAF);  /* MAF_1 : MAF의 이전 값이 나오게 됨. */
 SOC_D = DIF(SOC); 
 WAGE_D = DIF(WAGE);
 
 year=1979+_n_;   /*_n_ : 자동 변수 */
 time=_n_;
 
 if year < 1989 then ref=1;
  else if 1989 <= year < 1998 then ref=2;
  else ref=3;  
  
 cards;
2955 	5951 	131770 
2859 	6239 	156926 
3033 	6624 	179736 
3266 	6816 	200263 
3348 	7024 	216333 
3504 	7578 	236831 
3826 	7830 	257124 
4416 	8172 	281537 
4667 	8579 	327768 
4882 	9150 	396051 
4911 	9858 	472718 
5156 	10704 	552814 
4980 	11301 	632306 
4720 	11871 	700684 
4758 	12560 	773133 
4818 	13168 	868843 
4725 	13782 	983186 
4537 	14365 	1064134 
3917 	13603 	1060951 
4027 	13943 	1128112 
4293 	14603 	1227832 
4267 	15139 	1296891 
4241 	15841 	1458006 
4205 	15967 	1563866 
4290 	16427 	1679297 
4234 	16789 	1825079 
4167 	17181 	1934598 
4119 	17569 	2048577 
4079 	17784 	2168286 
;
run;

/* 그래프 그리기 */
proc gplot data=ex2_1;
 plot MAF * time;  /* 세로 * 가로 */
run;
quit;
/* 시간에 따라 취업자 수가 어떻게 변하는지
   -> 추세, 이상치 (4000정도로 떨어짐 -> 1998년 IMF)
*/
  
proc gplot data=ex2_1;
 plot MAF_D * time;
run;
quit;
/* -> 변동을 보기 위해서 DIF 함수를 사용하여 전시차의 값을 구하여 현재값 - 전시차값의 차이를 구해
      <변동성>을 확인해본다.
   -> 나중에 가서 변동성은 조금 낮아지는 것을 확인할 수 있다.
   -> (엑셀 확인) 범위 : 2000-5000으로 축을 작게 하면 변동성이 더 커보임. (다르게 확인됨)
   -> (엑셀 확인) 추세 확인 : MAF, SOC, WAGE / 변동성 확인 : MAF_D, SOC_D, WAGE_D
       이때, 변동성 확인을 할 때 단위는 다르므로 표준편차를 확인 -> 223 / 296 / 42,841
*/



/* WAGE -> SOC, MAF에 영향을 미칠까? 관계를 보고 싶음. */
/* 임금이 얼마나 증가하면, 취업자 수는 얼마나 증가할까? */
/* 모형 설정 : (SOC = b0 + b1*TIME + b2*WAGE + 오차) -> 모수 추정 -> 검정(b1, b2 추정, 잔차 확인) */ 

proc gplot data=ex2_1;
 plot 
;

proc autoreg data=ex2_1 plots;
 SOC: model SOC= year WAGE;
run;
/* Parameter estimates : y^ = -934713 + 476*year -0.000268*wage (모형 추정)
                        : year이 1 증가할수록 476만명 증가, : wage는 영향력이 없다.
   (이때, year, wage값을 넣으면 y - y^의 잔차를 구할 수 있음.)
   
   (오차간의 상관성 탐지할 때 ACF, PACF)
*/


proc autoreg data=ex2_1 plots;
 MAF : model MAF= year WAGE;
run;
/* y^ = -543906 + 276.3627*year -0.003349*wage (모형 추정)
                     : year의 년 단위가 증가할수록 276만명 증가 
                       / wage 증가할수록 -0.003349.. (3명, 4명정도? 감소)
                       
 (엑셀) y^ 계산 -> y - y^ : 잔차(resudual)그리기 -> 단위에 영향을 받기 때문에 표준화 잔차를 구해야할 것. */
/*                                               따라서, 표준화 잔차 (첫번째 그래프 확인) */
/* 두번째 그래프 : 회귀선, 	
   cook's distance : 오차간 차이 */
   

/* 회귀모형이 유의한지 유의하지 않은지 p-value값으로 각각 확인이 가능하지만 
  (회귀계수 = 0 인지 아닌지 판단), 
   다른 방법으로도 확인 가능 */
proc autoreg data=EX2_1;
 model MAF=YEAR WAGE;
 test YEAR=0, WAGE=0; 
 /*두개의 회귀계수가 0인지 아닌지 -> y를 설명하는데 있어 2개의 변수가 의미는 있다. (p-value : 0.000-)*/
 test YEAR=0;
run;

proc autoreg data=ex2_1;
 model MAF=YEAR WAGE;
 test YEAR=300; /* year가 영향을 미치는 정도가 300도 된다. */
run;

proc autoreg data=ex2_1;
 model MAF=YEAR WAGE;
 test YEAR=600; /* year가 영향을 미치는 정도가 600은 안된다. */
run;



/* classic 모형 -> dummy 모형 */
/* 더미(0, 1로 줌) 효과 : 기간, 항목(성별, 지역, 연령..) */
/* (기간에 대한 더미) 그래프가 올라갔다 내려가는 지점인 변화 (변곡점)를 이전과 이후로 나눠서 사용하는 것*/
/* (항목에 대한 더미) 남자, 여자 분포에 따른 그래프를 각각 지정 */


/* 프로그램 2.3 */
data ex2_2; set ex2_1;
 if      YEAR < 1989		  then T=0;
 else if 1989 <= Year < 1998  then T=1;
 else 						  T=2;
run;

proc autoreg data=ex2_2; 
 model SOC=YEAR;  /* WAGE : 유의미하지 않았기 때문에 뻈음 */
 by T;
run;
/* 절편, year 영향력이 모두 다름 (계수 값) / 모두 유의  -> 결과값 엑셀에 붙이기*/
/* SOC : 증가하는 추세이지만, 폭이 다르게 나타남. */
/* 폭을 이렇게 나눠서 했을 경우, 신뢰성이 낮아지게 됨. */

proc gplot data=ex2_1;
 plot SOC * time;  /* 세로 * 가로 */
run;
quit;
/* ==> 3구간으로 나눠지는 것을 확인할 수 있음. */












